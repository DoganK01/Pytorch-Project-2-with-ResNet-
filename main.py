"""Pytorch Project 2(with ResNet).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OowRfz8pGgLigyvUG2oY7ouLnTmqTdqT
    The project will continue
"""

#Proje devam ediyor.

import torch
import torch.nn as nn
import torch.nn.functional as F
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
import os

def read_images(path, num_of_img):
  array = np.zeros([num_of_img, 64*32])
  i=0
  for img in os.listdir(path):
    img_path = path + "\\" + img
    img = Image.open(img_path, mode = "r")
    data = np.asarray(img, dtype="uint8")
    data = data.flatten()
    array[i,:] = data
    i += 1
  return array

train_neg_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Train\neg" 
num_train_neg_img = 43390
train_neg_array = read_images(train_neg_path, num_train_neg_img)
input_train_neg_tensor = torch.from_numpy(train_neg_array)
label_train_neg_tensor = torch.zeros(num_train_neg_img, dtype=torch.long)

train_positive_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Train\pos" 
num_train_positive_img = 43390
train_positive_array = read_images(train_positive_path, num_train_positive_img)
input_train_positive_tensor = torch.from_numpy(train_positive_array)
label_train_positive_tensor = torch.ones(num_train_positive_img, dtype=torch.long)

x_train = torch.cat((input_train_neg_tensor, input_train_positive_tensor),0) 
y_train = torch.cat((label_train_neg_tensor, label_train_positive_tensor),0)

test_neg_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Test\neg" 
num_test_neg_img = 22050
test_neg_array = read_images(test_neg_path, num_test_neg_img)
input_test_neg_tensor = torch.from_numpy(test_neg_array)
label_test_neg_tensor = torch.zeros(num_test_neg_img, dtype=torch.long) 





test_positive_path = r"D\resnet\LSIFIR.tar\LSIFIR\Classification\Test\pos" 
num_test_positive_img = 5944
test_positive_array = read_images(test_positive_path, num_test_positive_img)
input_test_positive_tensor = torch.from_numpy(test_positive_array)
label_test_positive_tensor = torch.ones(num_test_positive_img, dtype=torch.long) 



x_test = torch.cat((input_test_neg_tensor, input_test_positive_tensor),0) 
y_test = torch.cat((label_test_neg_tensor, label_test_positive_tensor),0)

num_epochs = 100
num_classes = 2
batch_size = 2000
learning_rate = 0.0001

import torch.utils.data

train = torch.utils.data.TensorDataset(x_train, y_train) 
trainloader = torch.utils.data.DataLoader(train, batch_size = batch_size, shuffle = True) 

test = torch.utils.data.TensorDataset(x_test, y_test)
testloader = torch.utils.data.DataLoader(test, batch_size = batch_size, shuffle = False)

def Conv3x3(in_channel, out_channel, stride=1):
  return nn.Conv2d(in_channel, out_channel, kernel_size=3, padding=1, bias=False )

def Conv1x1(in_channel, out_channel, stride=1):
  return nn.Conv2d(in_channel, out_channel, kernel_size=1, padding=1, bias=False )

class BasicBlock(nn.Module):
  expansion=1
  def __init__(self, inplane, outplane, stride=1, downsample=None):
    super(BasicBlock,self).__init__()
    self.conv1 = Conv3x3(inplane, outplane, stride)
    self.batch_norm1 = nn.BatchNorm2d(outplane)
    self.relu = nn.ReLU(inplace = True) #sonucu kendisine e≈üitliyoruz.
    self.drop = nn.Dropout(0.9)
    self.conv2 = Conv3x3(outplane, outplane)
    self.batch_norm2 = nn.BatchNorm2d(outplane)
    self.downsample = downsample
    self.stride = stride
  def forward(self, x):
    identity = x
    out = self.conv1(x)
    out = self.batch_norm1(out)
    out = self.relu(out)
    out = self.drop(out)
    out = self.conv2(out)
    out = self.batch_norm2(out)
    out = self.drop(out)

    if self.downsample is not None:
      identity = self.downsample(x)

    out = out + identity
    out = self.relu(out)
    return out

class ResNet(nn.Module):

  def __init__():
    super(ResNet,self).__init__()
    self.inplane = 64
    self.conv1 = nn.Conv2d(1, 64, kernel_size = 7, stride = 2, padding = 3, bias = False)
    self.bn1 = nn.BatchNorm2d(64)
    




  def _make_layer(self, block, planes, num, stride=1):
    downsample=None
    if stride !=1 or self.inplane != planes*block.expansion:
      downsample = nn.Sequantial(
          Conv1x1(self.inplane, planes*block.expansion, stride)
          nn.BatchNorm2d(planes*block.expension))
    
    layers = []
    layers.append(block(self.inplane, planes, stride, downsample)
    self.inplane = planes*block.expansion

    for _ in range(1,num):
      layers.append(block(self.inplane, planes))
    

    return nn.Sequential(*layers)
    



  def forward():
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
